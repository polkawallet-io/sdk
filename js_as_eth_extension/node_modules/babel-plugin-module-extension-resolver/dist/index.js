"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const PLUGIN_NAME = "babel-plugin-module-extension-resolver";
const defaultOptions = {
    srcExtensions: [
        ".js",
        ".cjs",
        ".mjs",
        ".es",
        ".es6",
        ".ts",
        ".node",
        ".json",
    ],
    dstExtension: ".js",
    extensionsToKeep: [".json"],
};
exports.default = (babel, options) => {
    const { types } = babel;
    const normalizedOptions = Object.assign(Object.assign({}, defaultOptions), options);
    return {
        name: PLUGIN_NAME,
        visitor: {
            Program: {
                enter: (programPath, state) => {
                    const { filename } = state;
                    programPath.traverse({
                        CallExpression: (declaration) => {
                            handleCallExpression(types, declaration, filename, normalizedOptions);
                        },
                        ImportDeclaration: (declaration) => {
                            handleImportDeclaration(types, declaration, filename, normalizedOptions);
                        },
                        ExportDeclaration: (declaration) => {
                            handleExportDeclaration(types, declaration, filename, normalizedOptions);
                        },
                    }, state);
                },
            },
        },
    };
};
function handleCallExpression(types, declaration, fileName, options) {
    const callee = declaration.get("callee");
    if (!isRequireOrDynamicImport(callee)) {
        return;
    }
    const args = declaration.get("arguments");
    if (args.length !== 1) {
        return;
    }
    replaceSource(types, args[0], fileName, options);
}
function handleImportDeclaration(types, declaration, fileName, options) {
    const source = declaration.get("source");
    replaceSource(types, source, fileName, options);
}
function handleExportDeclaration(types, declaration, fileName, options) {
    const source = declaration.get("source");
    if (Array.isArray(source)) {
        return;
    }
    replaceSource(types, source, fileName, options);
}
function isRequireOrDynamicImport(callee) {
    if (callee.isImport()) {
        return true;
    }
    if (callee.isIdentifier() && callee.node.name === "require") {
        return true;
    }
    return false;
}
function replaceSource(types, source, fileName, options) {
    if (!source.isStringLiteral()) {
        return;
    }
    const sourcePath = source.node.value;
    if (sourcePath[0] !== ".") {
        return;
    }
    const baseDir = path_1.default.dirname(fileName);
    const resolvedPath = resolvePath(baseDir, sourcePath, options);
    const normalizedPath = normalizePath(resolvedPath);
    source.replaceWith(types.stringLiteral(normalizedPath));
}
function resolvePath(baseDir, sourcePath, options) {
    for (const title of [sourcePath, path_1.default.join(sourcePath, "index")]) {
        const resolvedPath = resolveExtension(baseDir, title, options);
        if (resolvedPath !== null) {
            return resolvedPath;
        }
    }
    return sourcePath;
}
function resolveExtension(baseDir, sourcePath, options) {
    const { srcExtensions, dstExtension, extensionsToKeep } = options;
    const absolutePath = path_1.default.join(baseDir, sourcePath);
    if (isFile(absolutePath)) {
        return sourcePath;
    }
    for (const extension of srcExtensions) {
        const resolvedPath = `${absolutePath}${extension}`;
        if (!isFile(resolvedPath)) {
            continue;
        }
        if (extensionsToKeep.includes(extension)) {
            return path_1.default.relative(baseDir, resolvedPath);
        }
        else {
            return path_1.default.relative(baseDir, `${absolutePath}${dstExtension}`);
        }
    }
    return null;
}
function normalizePath(originalPath) {
    let normalizedPath = originalPath;
    if (path_1.default.sep === "\\") {
        normalizedPath = normalizedPath.split(path_1.default.sep).join("/");
    }
    if (normalizedPath[0] !== ".") {
        normalizedPath = `./${normalizedPath}`;
    }
    return normalizedPath;
}
function isFile(pathName) {
    try {
        return fs_1.default.statSync(pathName).isFile();
    }
    catch (err) {
        return false;
    }
}
//# sourceMappingURL=index.js.map